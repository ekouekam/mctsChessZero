# -*- coding: utf-8 -*-
"""rl_mctsChessZero.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gHpTJhsoB0SBnXMA6Q3fzBN4UwDwpl5f

#rl_mctsChessZero
Intègre un moteur IA de jeu basé sur l'apprentissage par renforcement via l'arbre de recherche de Monte Carlo(MCTS)

 ## Explications des principales fonctionnalités :
 Board, Piece, Engine, et la classe Main
1. Board : Représente l'échiquier, initialise les pièces et gère les mouvements.
2. Piece : Représente une pièce individuelle sur l'échiquier.
3. Engine : Moteur IA qui gère l'algorithme MCTS. Chaque Node représente un état du jeu, et l'arbre MCTS explore les coups possibles pour choisir le meilleur coup.
4. Main : La classe principale qui gère le déroulement du jeu, en alternant entre les joueurs(humain contre IA).
## Améliorations possibles :
Ce code présente une structure de base pour un moteur d'échecs utilisant MCTS pour l'apprentissage par renforcement, mais beaucoup d'aspects peuvent être enrichis pour un jeu complet et performant.
Cette implémentation se concentre sur la structure de base et sur l'architecture du moteur de jeu, mais elle peut nécessiter des améliorations pour une version plus avancée et réaliste.

#Piece
Piece est responsable de la représentation d'une piece individuelle.
"""

from abc import ABC, abstractmethod

class Piece(ABC):
    """
    Classe représentant une pièce individuelle sur l'échiquier.
    Chaque pièce a une couleur (blanc ou noir), un nom (roi, dame, etc.),
    et des propriétés associées comme ses déplacements possibles.
    """

    PIECES_VALIDES = {'king', 'queen', 'rook', 'bishop', 'knight', 'pawn'}
    COULEURS_VALIDES = {'white', 'black'}

    def __init__(self, color, name):
        """
        Initialise une pièce.

        Args:
            color (str): La couleur de la pièce ('white' ou 'black').
            name (str): Le type de la pièce ('king', 'queen', 'rook', etc.).
        """
        if color.lower() not in self.COULEURS_VALIDES:
            raise ValueError(f"La couleur doit être 'white' ou 'black', reçu: {color}.")
        if name.lower() not in self.PIECES_VALIDES:
            raise ValueError(f"Nom invalide pour une pièce d'échecs: {name}.")

        self.color = color.lower()
        self.name = name.lower()

    def __str__(self):
        """
        Représente la pièce sous forme de chaîne abrégée.
        Exemples : 'WK' pour un roi blanc, 'BQ' pour une dame noire.

        Returns:
            str: Une représentation concise de la pièce.
        """
        return f"{self.color[0].upper()}{self.name[0].upper()}"

    def __repr__(self):
        return self.__str__()

    @abstractmethod
    def get_possible_moves(self, position, board):
        """
        Retourne une liste des mouvements possibles pour la pièce à partir d'une position donnée.
        Cette méthode doit être implémentée spécifiquement pour chaque type de pièce.

        Args:
            position (tuple): La position actuelle de la pièce (ligne, colonne).
            board (Board): L'état actuel de l'échiquier.

        Returns:
            list: Une liste de positions valides (sous forme de tuples) où la pièce peut se déplacer.
        """
        pass

    def is_valid_move(self, start, end, board):
        """
        Vérifie si un déplacement est valide pour cette pièce.
        Utilise la méthode get_possible_moves pour effectuer la validation.

        Args:
            start (tuple): La position de départ (ligne, colonne).
            end (tuple): La position d'arrivée (ligne, colonne).
            board (Board): L'état actuel de l'échiquier.

        Returns:
            bool: True si le mouvement est valide, False sinon.
        """
        possible_moves = self.get_possible_moves(start, board)
        return end in possible_moves


class King(Piece):
    """
    Classe représentant un roi sur l'échiquier.
    Le roi peut se déplacer d'une case dans n'importe quelle direction.
    """

    def __init__(self, color):
        super().__init__(color, 'king')

    def get_possible_moves(self, position, board):
        """
        Retourne la liste des mouvements valides pour le roi.
        Le roi peut se déplacer d'une case dans toutes les directions.

        Args:
            position (tuple): La position actuelle du roi (ligne, colonne).
            board (Board): L'état actuel de l'échiquier.

        Returns:
            list: Liste des mouvements valides pour le roi.
        """
        moves = []
        x, y = position
        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

        # Vérifier toutes les directions possibles.
        for dx, dy in directions:
            new_x, new_y = x + dx, y + dy
            if board.is_within_bounds((new_x, new_y)) and not board.is_occupied_by_color((new_x, new_y), self.color):
                moves.append((new_x, new_y))

        return moves

class Queen(Piece):
    """
    Classe représentant une dame sur l'échiquier.
    La dame peut se déplacer de manière illimitée en ligne droite ou en diagonale.
    """

    def __init__(self, color):
        super().__init__(color, 'queen')

    def get_possible_moves(self, position, board):
        """
        Retourne la liste des mouvements valides pour la dame.
        La dame peut se déplacer en ligne droite ou en diagonale.
        """
        moves = []
        x, y = position

        # Mouvements en ligne droite et en diagonale.
        directions = [
            (-1, 0), (1, 0), (0, -1), (0, 1),  # Verticale et horizontale
            (-1, -1), (-1, 1), (1, -1), (1, 1)  # Diagonales
        ]

        for dx, dy in directions:
            new_x, new_y = x, y
            while True:
                new_x, new_y = new_x + dx, new_y + dy
                if not board.is_within_bounds((new_x, new_y)):  # Si hors des limites
                    break
                if board.is_occupied_by_color((new_x, new_y), self.color):  # Si la case est occupée par la même couleur
                    break
                moves.append((new_x, new_y))
                if board.is_occupied_by_opponent((new_x, new_y), self.color):  # Si l'adversaire occupe la case, capturable
                    break
        return moves

class Pawn(Piece):
    def __init__(self, color):
        super().__init__(color, 'pawn')

    def get_possible_moves(self, position, board):
        """
        Retourne une liste des mouvements possibles pour le pion, prenant en compte
        les règles spécifiques comme la promotion et la direction de déplacement.
        """
        moves = []
        x, y = position
        direction = 1 if self.color == 'white' else -1  # Pion blanc va vers le bas, noir vers le haut

        # Mouvement simple d'une case en avant
        if board.is_within_bounds((x + direction, y)) and board.get_piece_at((x + direction, y)) is None:
            moves.append((x + direction, y))

        # Mouvement initial de deux cases (si le pion est à sa position de départ)
        if (self.color == 'white' and x == 1) or (self.color == 'black' and x == 6):
          if board.get_piece_at((x + 2 * direction, y)) is None:
            moves.append((x + 2 * direction, y))

        # Mouvement en diagonale pour capturer
        if board.is_within_bounds((x + direction, y + 1)) and board.get_piece_at((x + direction, y + 1)) and board.get_piece_at((x + direction, y + 1)).color != self.color:
            moves.append((x + direction, y + 1))
        if board.is_within_bounds((x + direction, y - 1)) and board.get_piece_at((x + direction, y - 1)) and board.get_piece_at((x + direction, y - 1)).color != self.color:
            moves.append((x + direction, y - 1))

        directions = [(-1, 0), (1, 0)] #haut bas
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if board.is_within_bounds((nx, ny)) and not board.is_occupied_by_color((nx, ny), self.color):
                moves.append((nx, ny))

        return moves


class Rook(Piece):
    def __init__(self, color):
        super().__init__(color, 'rook')

    def get_possible_moves(self, position, board):
        moves = []
        x, y = position
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Haut, bas, gauche, droite

        for dx, dy in directions:
            nx, ny = x, y
            while True:
                nx, ny = nx + dx, ny + dy
                if not board.is_within_bounds((nx, ny)):
                    break
                if board.get_piece_at((nx, ny)) is None:  # Case vide
                    moves.append((nx, ny))
                elif board.is_occupied_by_color((nx, ny), self.color):  # Même couleur
                    break
                else:  # Case occupée par une pièce adverse
                    moves.append((nx, ny))
                    break
        return moves

class Bishop(Piece):
    def __init__(self, color):
        super().__init__(color, 'bishop')

    def get_possible_moves(self, position, board):
        moves = []
        x, y = position
        directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]  # Diagonales (haut-gauche, haut-droit, bas-gauche, bas-droit)

        for dx, dy in directions:
            nx, ny = x, y
            while True:
                nx, ny = nx + dx, ny + dy
                if not board.is_within_bounds((nx, ny)):
                    break
                if board.get_piece_at((nx, ny)) is None:  # Case vide
                    moves.append((nx, ny))
                elif board.is_occupied_by_color((nx, ny), self.color):  # Même couleur
                    break
                else:  # Case occupée par une pièce adverse
                    moves.append((nx, ny))
                    break
        return moves

class Knight(Piece):
    def __init__(self, color):
        super().__init__(color, 'knight')

    def get_possible_moves(self, position, board):
        moves = []
        x, y = position
        # Les 8 positions possibles du cavalier
        directions = [(-2, -1), (-2, 1), (2, -1), (2, 1),
                      (-1, -2), (-1, 2), (1, -2), (1, 2)]

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if board.is_within_bounds((nx, ny)) and not board.is_occupied_by_color((nx, ny), self.color):
                moves.append((nx, ny))
        return moves

"""#Board
Board est responsable de la représentation de l'échiquier et des mouvements des pièces.
"""

class Board:
    """
    Classe représentant l'échiquier.
    Gère l'état des pièces, les mouvements et la validation des règles de base.
    """

    def __init__(self):
        """
        Initialise l'échiquier avec une grille 8x8 et place les pièces.
        """
        self.board = [[None for _ in range(8)] for _ in range(8)]  # Grille 8x8
        self.setup_board()

    def setup_board(self):
        """
        Place les pièces initiales sur l'échiquier selon les règles des échecs.
        """
        major_pieces = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook']

        # Placement des pièces noires
        for i in range(8):
            if major_pieces[i] == 'king':
                self.board[0][i] = King('black')
            elif major_pieces[i] == 'queen':
                self.board[0][i] = Queen('black')
            elif major_pieces[i] == 'rook':
                self.board[0][i] = Rook('black')
            elif major_pieces[i] == 'bishop':
                self.board[0][i] = Bishop('black')
            elif major_pieces[i] == 'knight':
                self.board[0][i] = Knight('black')

            self.board[1][i] = Pawn('black')

        # Placement des pièces blanches
        for i in range(8):
            if major_pieces[i] == 'king':
                self.board[7][i] = King('white')
            elif major_pieces[i] == 'queen':
                self.board[7][i] = Queen('white')
            elif major_pieces[i] == 'rook':
                self.board[7][i] = Rook('white')
            elif major_pieces[i] == 'bishop':
                self.board[7][i] = Bishop('white')
            elif major_pieces[i] == 'knight':
                self.board[7][i] = Knight('white')

            self.board[6][i] = Pawn('white')

    def display(self):
        """
        Affiche l'échiquier dans un format lisible.
        Les cases vides sont représentées par un '..'.
        """
        for row in self.board:
            print(" ".join([str(piece) if piece else ".." for piece in row]))
        print("\n")

    def is_within_bounds(self, position):
        """
        Vérifie si une position donnée est à l'intérieur des limites de l'échiquier.

        Args:
            position (tuple): La position à vérifier (ligne, colonne).

        Returns:
            bool: True si la position est valide, sinon False.
        """

        if position is None:  # Check if position is None
           return False
        row, col = position  # Order is (row, col)
        return 0 <= row < 8 and 0 <= col < 8

    def get_piece_at(self, position):
        """
        Retourne la pièce à une position donnée.

        Args:
            position (tuple): La position (ligne, colonne).

        Returns:
            Piece: La pièce à la position donnée, ou None si la case est vide.
        """
        if not self.is_within_bounds(position):
            return None
        row, col = position
        return self.board[row][col]

    def is_occupied_by_color(self, position, color):
        """
        Vérifie si une case est occupée par une pièce d'une couleur donnée.

        Args:
            position (tuple): La position à vérifier (ligne, colonne).
            color (str): La couleur ('white' ou 'black').

        Returns:
            bool: True si la case contient une pièce de la couleur spécifiée, sinon False.
        """
        piece = self.get_piece_at(position)
        return piece is not None and piece.color == color

    def is_occupied_by_opponent(self, position, color):
        """
        Vérifie si une case est occupée par une pièce de l'adversaire.

        Args:
            position (tuple): La position à vérifier (ligne, colonne).
            color (str): La couleur de la pièce à comparer.

        Returns:
            bool: True si la case contient une pièce d'une couleur opposée, sinon False.
        """
        piece = self.get_piece_at(position)
        return piece is not None and piece.color != color

    def is_valid_move(self, start, end):
        """
        Vérifie si un mouvement est valide en fonction des règles de base.

        Args:
            start (tuple): Position de départ (ligne, colonne).
            end (tuple): Position d'arrivée (ligne, colonne).

        Returns:
            bool: True si le déplacement est valide, sinon False.
        """
        if not self.is_within_bounds(start) or not self.is_within_bounds(end):
            return False  # Mouvement en dehors des limites
        piece = self.get_piece_at(start)
        if not piece:
            return False  # Aucune pièce à déplacer
        if self.is_occupied_by_color(end, piece.color):
            return False  # Impossible de capturer une pièce de la même couleur

        # Vérifie si le mouvement est valide pour cette pièce
        if piece.is_valid_move(start, end, self):
          return True

        # Validation du mouvement spécifique à la pièce
        return end in piece.get_possible_moves(start, self)

    def move(self, start, end):
        """
        Effectue un déplacement de pièce si celui-ci est valide.

        Args:
            start (tuple): Position de départ (ligne, colonne).
            end (tuple): Position d'arrivée (ligne, colonne).

        Returns:
            bool: True si le mouvement a été effectué, sinon False.
        """
        if not self.is_valid_move(start, end):
            return False  # Mouvement invalide
        piece = self.get_piece_at(start)
        self.board[end[0]][end[1]] = piece
        self.board[start[0]][start[1]] = None
        return True

    def get_all_valid_moves(self, color):
        """
        Retourne tous les mouvements valides pour une couleur donnée.

        Args:
            color (str): La couleur ('white' ou 'black').

        Returns:
            list: Une liste de tuples (start, end) représentant les mouvements valides.
        """
        valid_moves = []
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece and piece.color == color:
                    start = (row, col)
                    for move in piece.get_possible_moves(start, self):
                        if self.is_valid_move(start, move):
                            valid_moves.append((start, move))
        return valid_moves

    def is_pat(self,current_player):
        """
        Vérifie si la position actuelle est un pat (stalemate).
        """
        # Récupérer la couleur du joueur dont c'est le tour
        current_color = current_player

        # Vérifier si le roi du joueur est en échec
        if self.is_king_in_check(current_color):
            return False  # Si le roi est en échec, ce n'est pas un pat

        # Vérifier si le joueur ne peut effectuer aucun mouvement valide
        valid_moves = self.get_all_valid_moves(current_color)
        if not valid_moves:  # Si aucun mouvement valide
            return True  # Le pat est confirmé

        return False  # Le joueur peut encore faire des mouvements valides, pas un pat

    def is_king_in_check(self, color):
        """
        Vérifie si le roi du joueur de la couleur donnée est en échec.

        Args:
            color (str): La couleur du joueur ('white' ou 'black').

        Returns:
            bool: True si le roi est en échec, False sinon.
        """
        # Trouver la position du roi
        king_position = None
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece and piece.name == 'king' and piece.color == color:
                    king_position = (row, col)
                    break
            if king_position:
                break

        if not king_position:
            return False  # Le roi n'a pas été trouvé, ce qui est anormal

        # Vérifier si une pièce adverse peut attaquer cette position
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece and piece.color != color:  # Piece adverse
                    if piece.is_valid_move((row, col), king_position, self):
                        return True  # Le roi est en échec

        return False  # Le roi n'est pas en échec


    def is_check(self, color):
        """
        Vérifie si le roi de la couleur donnée est en échec.

        Args:
            color (str): La couleur ('white' ou 'black').

        Returns:
            bool: True si le roi de la couleur donnée est en échec, sinon False.
        """
        king_position = self.find_king(color)
        opponent_color = 'white' if color == 'black' else 'black'
        opponent_moves = self.get_all_valid_moves(opponent_color)

        for start, end in opponent_moves:
            if end == king_position:
                return True
        return False

    def is_checkmate(self, color):
        """
        Vérifie si la couleur donnée est en échec et mat.

        Args:
            color (str): La couleur ('white' ou 'black').

        Returns:
            bool: True si la couleur donnée est en échec et mat, sinon False.
        """
        if not self.is_check(color):
            return False  # Si le roi n'est pas en échec, il ne peut pas être en échec et mat

        valid_moves = self.get_all_valid_moves(color)
        for start, end in valid_moves:
            if self.move(start, end):  # Essaye de jouer un coup pour sortir de l'échec
                self.undo_move(start, end)  # Annuler le mouvement après test
                return False
        return True

    def undo_move(self, start, end):
        """
        Annule un mouvement de pièce, en rétablissant l'état précédent.

        Args:
            start (tuple): Position de départ (ligne, colonne).
            end (tuple): Position d'arrivée (ligne, colonne).
        """
        piece = self.get_piece_at(end)
        self.board[start[0]][start[1]] = piece
        self.board[end[0]][end[1]] = None

    def find_king(self, color):
        """
        Trouve la position du roi de la couleur donnée.

        Args:
            color (str): La couleur ('white' ou 'black').

        Returns:
            tuple: La position (ligne, colonne) du roi de la couleur donnée.
        """
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece and piece.name == 'king' and piece.color == color:
                    return (row, col)
        return None

"""#Engine
 Engine (Moteur de jeu de l'IA basé sur l'algorithme MCTS d'apprentissage par renforcement)

 Engine gère l'intégration de la logique de jeu de l'IA via l'algorithme de Monte Carlo en apprentissage par renforcement.
"""

import random
import math

class Node:
    def __init__(self, board, parent=None, move=None):
        self.board = board  # L'état du jeu à ce point
        self.parent = parent  # Le parent dans l'arbre
        self.move = move  # Le mouvement qui a mené à cet état
        self.children = []  # Enfants de ce noeud (états futurs possibles)
        self.visits = 0  # Nombre de fois que ce noeud a été exploré
        self.value = 0  # La valeur (récompense) associée à ce noeud

    def is_fully_expanded(self):
        """Vérifie si tous les enfants de ce noeud ont été générés"""
        return len(self.children) > 0

    def best_child(self, exploration_weight=1.41):
        """Choisit le meilleur enfant en fonction de l'UCT (Upper Confidence Bound for Trees)"""
        best_value = -float('inf')
        best_move = None
        for child in self.children:
            uct_value = (child.value / (child.visits + 1e-6)) + exploration_weight * math.sqrt(math.log(self.visits + 1) / (child.visits + 1e-6))
            if uct_value > best_value:
                best_value = uct_value
                best_move = child
        return best_move

class Engine:
    def __init__(self, board, current_player='white'):
        self.board = board
        self.root_node = Node(self.board, move=None)
        self.current_player = current_player

    def selection(self):
        """Sélectionne le meilleur noeud à explorer selon la stratégie UCT"""
        node = self.root_node
        while node.is_fully_expanded():
            node = node.best_child()
        return node

    def expansion(self, node):
        """Génère les nouveaux noeuds (mouvements possibles) à partir du noeud courant"""
        for move in self.generate_legal_moves(node.board):
            new_board = self.simulate_move(node.board, move)
            child_node = Node(new_board, parent=node, move=move)
            node.children.append(child_node)

    def simulation(self, node):
        """Simule une partie à partir de l'état actuel du noeud jusqu'à un état terminal"""
        board = node.board
        while not self.is_game_over(board):
            move = random.choice(self.generate_legal_moves(board))
            board = self.simulate_move(board, move)
        return self.evaluate_board(board)

    def backpropagation(self, node, reward):
        """Propager la récompense vers le parent"""
        while node:
            node.visits += 1
            node.value += reward
            node = node.parent

    def generate_legal_moves(self, board):
        """
            Génère tous les mouvements légaux à partir d'un état donné (simplifié ici).
            Cette méthode doit être appelée avec l'objet Board complet.
        """
        legal_moves = []
        for row in range(8):
            for col in range(8):
                piece = board.get_piece_at((row, col))  # Utilisez l'objet Board pour obtenir la pièce
                if piece and piece.color == self.current_player:  # L'IA joue selon sa couleur
                   moves = piece.get_possible_moves((row, col), board)  # Passe l'instance Board
                   for move in moves:
                       if board.is_valid_move((row, col), move):  # Vérifie les mouvements valides
                          legal_moves.append(((row, col), move))  # Enregistre les mouvements valides
        return legal_moves


    def simulate_move(self, board_obj, move):  # Changed parameter name to board_obj
        """Simule un mouvement et renvoie un nouvel état du jeu"""
        # Access the board's internal representation for deep copy

        board = board_obj.board  # Get the actual board (list of lists) from the Board object
        new_board = [row[:] for row in board] # Faire une copie profonde de l'échiquier
        start, end = move
        piece = new_board[start[0]][start[1]]
        new_board[end[0]][end[1]] = piece
        new_board[start[0]][start[1]] = None

        # Create a new Board object with the updated board state
        new_board_obj = Board()  # Create a new Board object
        new_board_obj.board = new_board  # Set the internal board of the new object
        return new_board_obj  # Return the new Board object

    def is_game_over(self, board_obj): # Changed parameter name to board_obj
        """Vérifie si le jeu est terminé (échec, mat, ou pat)"""
        # Access the board using board_obj.board
        return self.is_checkmate(board_obj, "white") or self.is_checkmate(board_obj, "black") # Pass board_obj

    def evaluate_board(self, board_obj): # Changed parameter name to board_obj
        """Retourne une évaluation de l'état actuel du jeu"""
        if self.is_checkmate(board_obj, "white"): # Pass board_obj
            return -1  # Perte pour le joueur blanc
        elif self.is_checkmate(board_obj, "black"): # Pass board_obj
            return 1  # Victoire pour le joueur blanc
        else:
            return random.uniform(-0.5, 0.5)  # Une évaluation aléatoire pour les positions non terminales


    def is_checkmate(self, board_obj, color):
        """Vérifie si la couleur donnée est en échec et mat"""
        if not self.is_check(board_obj, color):
            return False  # Si le roi n'est pas en échec, il ne peut pas être en échec et mat

        valid_moves = self.get_all_valid_moves(board_obj, color)
        for start, end in valid_moves:
            if board_obj.move(start, end):  # Use board_obj.move to call the Board's move method
                board_obj.undo_move(start, end)  # Annuler le mouvement après test
                return False
        return True

    def is_check(self, board_obj, color): # Changed parameter name to board_obj
        """Vérifie si le roi de la couleur donnée est en échec"""
        king_position = self.find_king(board_obj, color) # Pass board_obj
        opponent_color = "white" if color == "black" else "black"
        opponent_moves = self.get_all_valid_moves(board_obj, opponent_color) # Pass board_obj

        for start, end in opponent_moves:
            if end == king_position:
                return True
        return False

    def find_king(self, board_obj, color): # Changed parameter name to board_obj
        """Retourne la position du roi d'une couleur donnée"""
        # Access the board using board_obj.board
        board = board_obj.board
        for row in range(8):
            for col in range(8):
                piece = board[row][col] # Access using the nested list
                if piece and piece.name == "king" and piece.color == color:
                    return (row, col)
        return None

    def get_all_valid_moves(self, board_obj, color): # Changed parameter name to board_obj
        """Retourne tous les mouvements valides pour une couleur donnée"""
        valid_moves = []
        # Access the board using board_obj.board
        board = board_obj.board
        for row in range(8):
            for col in range(8):
                piece = board[row][col] # Access using the nested list
                if piece and piece.color == color:
                    start = (row, col)
                    for move in piece.get_possible_moves(start, self.board):
                        if self.is_valid_move(board_obj, start, move): # Pass board_obj
                            valid_moves.append((start, move))
        return valid_moves

    def is_valid_move(self, board_obj, start, end): # Changed parameter name to board_obj
        """Vérifie si un mouvement est valide pour une pièce donnée"""
        # Access the board using board_obj.board
        board = board_obj.board
        piece = board[start[0]][start[1]] # Access using the nested list
        return piece.is_valid_move(start, end, self.board)

    def mcts(self, iterations=10000):
        """Exécute l'algorithme MCTS pour déterminer le meilleur coup"""
        for _ in range(iterations):
            node = self.selection()
            self.expansion(node)
            reward = self.simulation(node)
            self.backpropagation(node, reward)

        # Retourner le meilleur coup basé sur l'UCT après les itérations
        best_child = self.root_node.best_child(0)
        return best_child.move

"""#Main
Main (exécution du jeu)

"""

class Main:
    def __init__(self):
        self.board = Board()
        self.engine = Engine(self.board, current_player='white') #joueur IA
        self.current_player = 'black' #joueur humain
        self.game_over = False

    def play(self):
        """Lance la partie et gère les tours de jeu"""
        while not self.game_over:
            self.board.display()
            if self.current_player == 'white':
                print("C'est au tour des blancs.")
            else:
                print("C'est au tour des noirs.")

            if self.current_player == 'white':
                # Si le joueur humain joue pour les blancs
                move = self.get_human_move()
            else:
                # Moteur MCTS pour les noirs
                move = self.engine.mcts()

            print(f"Le mouvement choisi est: {move}")
            start, end = move
            if not self.board.move(start, end):
                print("Mouvement invalide, réessayez.")
                continue

            if self.is_game_over():
                self.board.display()
                print(f"{self.current_player.capitalize()} a gagné !")
                self.game_over = True
                break

            self.current_player = 'black' if self.current_player == 'white' else 'white'

    def get_human_move(self):
        """Permet à un joueur humain de choisir un mouvement"""
        move_valid = False
        while not move_valid:
            move_input = input("Entrez votre coup (ex: e2e4): ")
            try:
                start, end = self.parse_move(move_input)
                if self.board.is_valid_move(start, end):
                    move_valid = True
                else:
                    print("Mouvement invalide. Essayez encore.")
            except ValueError:
                print("Format de coup invalide. Exemple : 'e2e4'.")
        return start, end

    def parse_move(self, move_input):
        """
        Convertit une entrée du joueur sous forme de 'e2e4' en indices de tableau (ex: (6, 4), (4, 4)).
        """
        try:
            # Vérifier si l'entrée est correcte (ex: 4 caractères)
            if len(move_input) != 4:
                raise ValueError("Le format du coup est incorrect. Utilisez la forme 'e2e4'.")

            start_str = move_input[:2]  # Premiers 2 caractères pour la position de départ (ex: 'e2')
            end_str = move_input[2:]    # Derniers 2 caractères pour la position d'arrivée (ex: 'e4')

            start = self.convert_position(start_str)
            end = self.convert_position(end_str)

            # Vérifier si la conversion a réussi avant de retourner
            if start is None or end is None:
                raise ValueError("Position invalide. Veuillez utiliser des positions valides comme 'e2e4'.")

            return start, end
        except (ValueError, IndexError):
            print("Erreur lors de l'analyse du mouvement. Veuillez réessayer.")  # Affiche un message plus informatif
            return None, None

    def convert_position(self, pos):
        """Convertit une position comme 'e2' en coordonnées de l'échiquier (ligne, colonne)"""
        #column_mapping = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}
        try:  # Ajout d'un bloc try pour gérer les erreurs
            #column = column_mapping[pos[0].lower()]
            column = ord(pos[0].lower()) - ord('a')
            row = 8 - int(pos[1]) # Le rang 1 est en bas de l'échiquier, donc on inverse
            return (row , column)
        except (KeyError, ValueError):
            print(f"Position invalide: {pos}. Veuillez utiliser une notation algébrique valide.")
            return None  # Retourne None en cas d'erreur

    def is_game_over(self):
        """Vérifie la condition de fin de jeu"""
        return self.board.is_checkmate('white') or self.board.is_checkmate('black') or self.board.is_pat(self.current_player)

if __name__ == "__main__":
    game = Main()
    game.play()